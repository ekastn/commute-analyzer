// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: commute.sql

package store

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/paulmach/orb"
)

const createCommute = `-- name: CreateCommute :one
INSERT INTO commutes (
    user_id, name, home_point, office_point, route_geometry,
    distance_km, duration_min, vehicle, fuel_price, days_per_week,
    annual_cost, annual_minutes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, annual_cost, annual_minutes, created_at
`

type CreateCommuteParams struct {
	UserID        uuid.UUID
	Name          *string
	HomePoint     orb.Point
	OfficePoint   orb.Point
	RouteGeometry orb.LineString
	DistanceKm    float64
	DurationMin   float64
	Vehicle       string
	FuelPrice     int32
	DaysPerWeek   int16
	AnnualCost    int64
	AnnualMinutes int64
}

type CreateCommuteRow struct {
	ID            uuid.UUID
	AnnualCost    int64
	AnnualMinutes int64
	CreatedAt     time.Time
}

func (q *Queries) CreateCommute(ctx context.Context, arg CreateCommuteParams) (CreateCommuteRow, error) {
	row := q.db.QueryRow(ctx, createCommute,
		arg.UserID,
		arg.Name,
		arg.HomePoint,
		arg.OfficePoint,
		arg.RouteGeometry,
		arg.DistanceKm,
		arg.DurationMin,
		arg.Vehicle,
		arg.FuelPrice,
		arg.DaysPerWeek,
		arg.AnnualCost,
		arg.AnnualMinutes,
	)
	var i CreateCommuteRow
	err := row.Scan(
		&i.ID,
		&i.AnnualCost,
		&i.AnnualMinutes,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCommute = `-- name: DeleteCommute :exec
DELETE FROM commutes WHERE id = $1
`

func (q *Queries) DeleteCommute(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCommute, id)
	return err
}

const getCommute = `-- name: GetCommute :one
SELECT id, user_id, name, home_point, office_point, route_geometry, distance_km, duration_min, vehicle, fuel_price, days_per_week, annual_cost, annual_minutes, created_at, updated_at FROM commutes WHERE id = $1
`

func (q *Queries) GetCommute(ctx context.Context, id uuid.UUID) (Commute, error) {
	row := q.db.QueryRow(ctx, getCommute, id)
	var i Commute
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.HomePoint,
		&i.OfficePoint,
		&i.RouteGeometry,
		&i.DistanceKm,
		&i.DurationMin,
		&i.Vehicle,
		&i.FuelPrice,
		&i.DaysPerWeek,
		&i.AnnualCost,
		&i.AnnualMinutes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCommutesByUser = `-- name: ListCommutesByUser :many
SELECT id, user_id, name, home_point, office_point, route_geometry, distance_km, duration_min, vehicle, fuel_price, days_per_week, annual_cost, annual_minutes, created_at, updated_at
FROM commutes WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListCommutesByUser(ctx context.Context, userID uuid.UUID) ([]Commute, error) {
	rows, err := q.db.Query(ctx, listCommutesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Commute{}
	for rows.Next() {
		var i Commute
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.HomePoint,
			&i.OfficePoint,
			&i.RouteGeometry,
			&i.DistanceKm,
			&i.DurationMin,
			&i.Vehicle,
			&i.FuelPrice,
			&i.DaysPerWeek,
			&i.AnnualCost,
			&i.AnnualMinutes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCommute = `-- name: UpdateCommute :one
UPDATE commutes SET name = $2, updated_at = NOW() WHERE id = $1 RETURNING id
`

type UpdateCommuteParams struct {
	ID   uuid.UUID
	Name *string
}

func (q *Queries) UpdateCommute(ctx context.Context, arg UpdateCommuteParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, updateCommute, arg.ID, arg.Name)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
